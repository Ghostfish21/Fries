using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/// <summary>
/// 这是从 React App.tsx 中把“模型逻辑”完整翻译过来的 Unity 版本。
/// - 控制流严格按照 processTick / createAgents / synthesizeHybridScene 等函数翻译
/// - 数学公式、阈值、概率、状态机更新全部保持一致
/// - 数据部分只放了部分示例，其余请按 data.ts 补完
/// </summary>
public class ArmstrongEngine : MonoBehaviour {
    #region ==== 基础类型（对应 types.ts） ====

    [Serializable]
    public class ElementDef {
        public string key;
        public string label;
        public string role;
        public string location;
        public string desc;
        public string color;
        public int phaseIndex;
        public string next; // Generates
        public string counter; // Overcomes
        public string prev; // Generated by
        public string weakness; // Overcomed by
    }

    [Serializable]
    public class LegendDef {
        public string name;
        public string type;
        public string quote;
        public string archetypeKey;
    }

    [Serializable]
    public class GameDNA {
        public string prefix;
        public string suffix;
        public string genre;
        public List<string> keywords = new List<string>();
    }

    [Serializable]
    public class LocationDef {
        public string id;
        public float x;
        public float y;
        public string color;
        public string label;
        public string elementType;
        public bool isDynamic;
        public int ownerId;
        public string sceneName;
        public GameDNA dna;
        public bool isHybrid;
        public double createdAt; // 用 Time.timeSinceLevelLoad
        public string pitch;

        // Synthesis state
        public string synthesisSourceId;
        public float? synthesisProgress;
    }

    [Serializable]
    public class LocationState {
        public string id;
        public double gold;
        public double maxGold;
    }

    [Serializable]
    public class HistoricalEvent {
        public double year;
        public string type; // "GENERATE" | "CRASH" | "OVERCOME"
        public string source;
        public string target;
        public string title;
        public string desc;
    }

    [Serializable]
    public class RandomEvent {
        public string title;
        public string desc;
    }

    [Serializable]
    public class DecisionBias {
        public double riskAppetite; // 0-1
        public double irrationality; // 0-1
        public List<string> obsessions = new List<string>();
        public List<string> phobias = new List<string>();
    }

    [Serializable]
    public class ArchetypeDef {
        public string key;
        public string name;
        public string label_cn;
        public string desc;
        public DecisionBias bias;
        public string color;
        public string icon; // text
    }

    [Serializable]
    public class Agent {
        public int id;
        public string name;
        public string type;
        public string role;
        public string baseQuote;
        public float x;
        public float y;
        public float targetX;
        public float targetY;
        public double wealth;
        public double energy;
        public string status; // 'working' | 'bankrupt' | 'panic' | 'rich' | 'inspired' | 'stressed' | 'resting'
        public string thought;
        public int moodTimer;
        public int waitTimer;
        public int loiterTimer;
        public string color;
        public bool isMoving;
        public List<string> inspirations = new List<string>();
        public string project;
        public string archetypeKey;
    }

    [Serializable]
    public class LogEntry {
        public string id;
        public double year;
        public string type; // 'NEUTRAL' | 'HISTORY_GOOD' | 'HISTORY_BAD' | 'GENERATE' | 'OVERCOME'
        public string msg;
        public string source;
        public string target;
    }

    [Serializable]
    public class GameDate {
        public int year;
        public string month;
        public int monthIndex;
    }

    #endregion

    #region ==== 常量 & 数据（对应 data.ts） ====

    public const double START_YEAR = 1970.0;
    public const int TICKS_PER_YEAR = 12;
    public const double ECM_CYCLE_YEARS = 8.6;
    public const float TICK_RATE_MS = 800f;
    public const double BASE_RECOVERY_SPEED = 0.08;

    // 元素配置（完整照 data.ts）
    public static readonly ElementDef[] ELEMENTS = new[] {
        new ElementDef {
            key = "METAL",
            label = "金 (Tech)",
            role = "Engine Architect",
            location = "Tech Park",
            desc = "底层技术 / 引擎 / 优化",
            color = "#94a3b8",
            phaseIndex = 0,
            next = "WATER", counter = "WOOD", prev = "EARTH", weakness = "FIRE"
        },
        new ElementDef {
            key = "WATER",
            label = "水 (Capital)",
            role = "Publisher CEO",
            location = "Wall St.",
            desc = "商业模式 / 流量 / 资金",
            color = "#3b82f6",
            phaseIndex = 1,
            next = "WOOD", counter = "FIRE", prev = "METAL", weakness = "EARTH"
        },
        new ElementDef {
            key = "WOOD",
            label = "木 (Content)",
            role = "Game Designer",
            location = "Garage",
            desc = "玩法 / 创意 / 艺术",
            color = "#22c55e",
            phaseIndex = 2,
            next = "FIRE", counter = "EARTH", prev = "WATER", weakness = "METAL"
        },
        new ElementDef {
            key = "FIRE",
            label = "火 (Hype)",
            role = "Visionary",
            location = "Media Center",
            desc = "营销 / 叙事 / 话题",
            color = "#ef4444",
            phaseIndex = 3,
            next = "EARTH", counter = "METAL", prev = "WOOD", weakness = "WATER"
        },
        new ElementDef {
            key = "EARTH",
            label = "土 (Platform)",
            role = "Platform Lord",
            location = "HQ Tower",
            desc = "平台 / 硬件 / 垄断",
            color = "#eab308",
            phaseIndex = 4,
            next = "METAL", counter = "WATER", prev = "FIRE", weakness = "WOOD"
        }
    };

    // 在 TS 中 ELEMENT_MAP = ELEMENTS.reduce((acc, el, index) => { acc[el.key] = { ...el, index }; });
    public class ElementConfig : ElementDef {
        public int index;
    }

    public static readonly Dictionary<string, ElementConfig> ELEMENT_MAP =
        ELEMENTS.Select((el, idx) => new ElementConfig {
                key = el.key,
                label = el.label,
                role = el.role,
                location = el.location,
                desc = el.desc,
                color = el.color,
                phaseIndex = el.phaseIndex,
                next = el.next,
                counter = el.counter,
                prev = el.prev,
                weakness = el.weakness,
                index = idx
            })
            .ToDictionary(e => e.key, e => e);

    // 游戏概念（Yin Inspiration）
    public static readonly Dictionary<string, List<string>> GAME_CONCEPTS =
        new Dictionary<string, List<string>> {
            {
                "METAL",
                new List<string> {
                    "Ray Tracing", "Physics Engine", "Netcode", "Vulkan API", "ECS Architecture", "Procedural Gen",
                    "Quantum AI"
                }
            }, {
                "WATER",
                new List<string>
                    { "Loot Box", "Battle Pass", "Retention", "User Acquisition", "Micro-tx", "DAU Growth", "IPO" }
            }, {
                "WOOD",
                new List<string> {
                    "Branching Narrative", "Environmental Story", "Level Design", "Character Arc", "Art Style",
                    "Soundtrack", "Pixel Art"
                }
            }, {
                "FIRE",
                new List<string> {
                    "Viral Trailer", "E3 Demo", "Influencer Campaign", "Esports Event", "Community Drama", "Hype Train",
                    "Leaks"
                }
            }, {
                "EARTH",
                new List<string> {
                    "Console Exclusive", "Cloud Streaming", "VR Headset", "App Store Feat", "Hardware Spec",
                    "Controller API", "Ecosystem"
                }
            },
        };

    public static readonly string[] PROJECT_PREFIXES = new[] {
        "Project", "Codename", "Initiative", "Operation", "Protocol", "System", "Phase", "Echo"
    };

    // BAZI_ARCHETYPES（这里只放少量示例，逻辑完全相同——数据请按 data.ts 补全）
    public static readonly Dictionary<string, ArchetypeDef> BAZI_ARCHETYPES =
        new Dictionary<string, ArchetypeDef> {
            {
                "MANAGER",
                new ArchetypeDef {
                    key = "MANAGER",
                    name = "Manager",
                    label_cn = "管理者",
                    desc = "稳健执行型",
                    color = "#64748b",
                    icon = "M",
                    bias = new DecisionBias {
                        riskAppetite = 0.4,
                        irrationality = 0.3,
                        obsessions = new List<string> { "EARTH" },
                        phobias = new List<string> { "FIRE" }
                    }
                }
            }, {
                "CREATOR",
                new ArchetypeDef {
                    key = "CREATOR",
                    name = "Creator",
                    label_cn = "创作者",
                    desc = "偏重灵感与内容",
                    color = "#22c55e",
                    icon = "C",
                    bias = new DecisionBias {
                        riskAppetite = 0.6,
                        irrationality = 0.6,
                        obsessions = new List<string> { "WOOD" },
                        phobias = new List<string> { "METAL" }
                    }
                }
            }, {
                "WOLF",
                new ArchetypeDef {
                    key = "WOLF",
                    name = "Wolf",
                    label_cn = "掠夺者",
                    desc = "偏好掠夺与套利",
                    color = "#f97316",
                    icon = "W",
                    bias = new DecisionBias {
                        riskAppetite = 0.9,
                        irrationality = 0.5,
                        obsessions = new List<string> { "WATER" },
                        phobias = new List<string> { }
                    }
                }
            },
            // TODO: 其他 Archetype 按 data.ts 补全
        };

    // TEN_GODS_EVENTS（这里只放 OUTPUT 的前几条示例）
    public static class TEN_GODS_EVENTS {
        public static readonly string[] OUTPUT = {
            "shipping", "co-developing", "hard-launching"
            // TODO: 按 data.ts 补全
        };
    }

    // LEGENDARY_SCENES（只示例 METAL 的前几条）
    public class LegendaryScene {
        public string name;
        public GameDNA dna;
    }

    public static readonly Dictionary<string, List<LegendaryScene>> LEGENDARY_SCENES =
        new Dictionary<string, List<LegendaryScene>> {
            {
                "METAL",
                new List<LegendaryScene> {
                    new LegendaryScene {
                        name = "E1M1 Hangar",
                        dna = new GameDNA {
                            prefix = "Doom",
                            suffix = "Hangar",
                            genre = "FPS",
                            keywords = new List<string> { "Demons", "Shotguns" }
                        }
                    },
                    new LegendaryScene {
                        name = "Unreal Core",
                        dna = new GameDNA {
                            prefix = "Unreal",
                            suffix = "Tournament",
                            genre = "Arena",
                            keywords = new List<string> { "Headshots", "Speed" }
                        }
                    },
                }
            },
            // TODO: 其他元素的 LEGENDARY_SCENES 按 data.ts 补全
        };

    // LOCATIONS
    public static readonly List<LocationDef> INITIAL_LOCATIONS = new List<LocationDef> {
        new LocationDef {
            id = "Tech Park", x = 15f, y = 15f, color = "#94a3b8", label = "ENGINE LABS", elementType = "METAL",
            isDynamic = false
        },
        new LocationDef {
            id = "Wall St.", x = 85f, y = 15f, color = "#3b82f6", label = "IPO CENTER", elementType = "WATER",
            isDynamic = false
        },
        new LocationDef {
            id = "Garage", x = 15f, y = 85f, color = "#22c55e", label = "INDIE STUDIO", elementType = "WOOD",
            isDynamic = false
        },
        new LocationDef {
            id = "Media Center", x = 85f, y = 85f, color = "#ef4444", label = "E3 STAGE", elementType = "FIRE",
            isDynamic = false
        },
        new LocationDef {
            id = "HQ Tower", x = 50f, y = 50f, color = "#eab308", label = "PLATFORM HQ", elementType = "EARTH",
            isDynamic = false
        },
    };

    // LEGENDS（示例，数据可按 data.ts 补全）
    public static readonly List<LegendDef> LEGENDS = new List<LegendDef> {
        new LegendDef
            { name = "John Carmack", type = "METAL", quote = "We write the engine.", archetypeKey = "CREATOR" },
        new LegendDef { name = "Gabe Newell", type = "EARTH", quote = "Sales are coming.", archetypeKey = "TYCOON" },
        // TODO: 把 data.ts 中 LEGENDS 全部搬过来
    };

    // HISTORICAL_EVENTS（可完全搬，数量不多）
    public static readonly List<HistoricalEvent> HISTORICAL_EVENTS = new List<HistoricalEvent> {
        new HistoricalEvent {
            year = 1972.5, type = "GENERATE", source = "METAL", target = "WATER", title = "Pong 发布",
            desc = "雅达利成立，电子游戏产业正式诞生。"
        },
        new HistoricalEvent {
            year = 1977.0, type = "GENERATE", source = "METAL", target = "WOOD", title = "Atari 2600",
            desc = "家用主机时代开启。"
        },
        new HistoricalEvent {
            year = 1983.5, type = "CRASH", source = "FIRE", target = "METAL", title = "雅达利大崩溃",
            desc = "【ECM转折点】北美市场归零，信心彻底崩塌。"
        },
        // TODO: 按 data.ts 补全后续历史事件
    };

    // RANDOM_EVENTS（结构完全一致，内部文本可按 data.ts 补全）
    public static class RANDOM_EVENTS {
        public static readonly Dictionary<string, List<RandomEvent>> OVERCOME =
            new Dictionary<string, List<RandomEvent>> {
                {
                    "METAL", new List<RandomEvent> {
                        new RandomEvent { title = "引擎过剩", desc = "技术堆叠导致维护成本暴涨。" }
                    }
                },
                // TODO: 其他元素补全
            };

        public static readonly Dictionary<string, List<RandomEvent>> GENERATE =
            new Dictionary<string, List<RandomEvent>> {
                {
                    "METAL", new List<RandomEvent> {
                        new RandomEvent { title = "新主机架构", desc = "更高性能带来新一轮内容爆发。" }
                    }
                },
                // TODO: 其他元素补全
            };

        public static readonly List<RandomEvent> BEAR = new List<RandomEvent> {
            new RandomEvent { title = "熊市情绪", desc = "全球资金避险，估值普遍收缩。" }
            // TODO: 可按 data.ts 扩展更多
        };
    }

    // LORE_LIBRARY（只给出结构和少量示例）
    public static class LORE_LIBRARY {
        public static class HYBRID_TEMPLATES {
            public static readonly List<string> GENERATE = new List<string> {
                "{S_PREFIX}-{T_SUFFIX}: A {GENRE} blending {S_KEY} with {T_KEY}."
            };

            public static readonly List<string> OVERCOME = new List<string> {
                "{T_PREFIX}-{S_SUFFIX}: {GENRE} where {S_KEY} rewrites {T_KEY}."
            };

            public static readonly List<string> SAME = new List<string> {
                "{S_PREFIX}{T_SUFFIX}: A focused {GENRE} about {S_KEY} & {T_KEY}."
            };

            public static readonly List<string> DEFAULT = new List<string> {
                "{S_PREFIX} vs {T_PREFIX}: Experimental {GENRE}."
            };
        }

        public static class EVENT_LOGS {
            public static readonly List<string> MERGE = new List<string> {
                "merged two legendary IPs into",
                // TODO: 按 data.ts 补全
            };

            public static readonly List<string> CONSTRUCT = new List<string> {
                "constructed a new scene at the frontier.",
            };

            public static readonly List<string> EPIPHANY = new List<string> {
                "had an epiphany and shipped a GOTY candidate.",
            };
        }
    }

    // 初始元素数值（Record<string, number>）
    public static Dictionary<string, double> INITIAL_VALUES =>
        ELEMENTS.ToDictionary(e => e.key, e => 50.0);

    #endregion
    
    // TODO 看到这里了

    #region ==== 实例状态（对应 App 里的 useState / useRef） ====

    [Header("Simulation State")] public double year = START_YEAR;
    public bool isRunning = false;
    public float speedMultiplier = 1f; // 1 / 5 / 0.2

    // 核心状态
    private Dictionary<string, double> elementValues;
    private List<Agent> agents;
    private List<LocationDef> structures;
    private List<LocationState> locationStates;
    private List<LogEntry> logs;

    // “Ref” 状态（对应 useRef）
    private double lastLogYear;
    private string lastEventTitle = "";
    private string currentCrashElement = null;

    // tick 定时
    private float tickTimerMs = 0f;

    #endregion

    #region ==== 生命周期 ====

    private void Awake() {
        ResetSimulation();
    }

    private void Update() {
        if (!isRunning) return;

        float intervalMs = TICK_RATE_MS / Mathf.Max(0.0001f, speedMultiplier);
        tickTimerMs += Time.deltaTime * 1000f;

        while (tickTimerMs >= intervalMs && isRunning) {
            tickTimerMs -= intervalMs;
            ProcessTick();
        }
    }

    public void StartSimulation() {
        isRunning = true;
    }

    public void PauseSimulation() {
        isRunning = false;
    }

    public void ToggleSpeed() {
        // 与 TS 逻辑一致：1 -> 5 -> 0.2 -> 1
        if (Mathf.Approximately(speedMultiplier, 1f)) speedMultiplier = 5f;
        else if (Mathf.Approximately(speedMultiplier, 5f)) speedMultiplier = 0.2f;
        else speedMultiplier = 1f;
    }

    public void ResetSimulation() {
        year = START_YEAR;
        elementValues = INITIAL_VALUES;
        agents = CreateAgents();
        structures = INITIAL_LOCATIONS.Select(CloneLocation).ToList();
        locationStates = structures
            .Select(l => new LocationState { id = l.id, gold = 50.0, maxGold = 200.0 })
            .ToList();
        logs = new List<LogEntry> {
            new LogEntry {
                id = "init",
                year = START_YEAR,
                type = "NEUTRAL",
                msg = "Armstrong ECM Engine Initialized.",
                source = "METAL",
                target = "METAL"
            }
        };

        lastLogYear = START_YEAR;
        lastEventTitle = "";
        currentCrashElement = null;
        tickTimerMs = 0f;
    }

    #endregion

    #region ==== 数学 & 辅助函数（严格照 App.tsx） ====

    private static double GetGlobalConfidence(double year) {
        double angle = (2.0 * Math.PI * (year - 2007.15)) / ECM_CYCLE_YEARS;
        return Math.Cos(angle);
    }

    private static double GetElementPiFactor(int phaseIndex, double year) {
        double angle = (2.0 * Math.PI * (year - START_YEAR)) / ECM_CYCLE_YEARS;
        double phaseShift = (phaseIndex * 2.0 * Math.PI) / 5.0;
        return Math.Sin(angle + phaseShift);
    }

    private static ElementDef GetHeavenElement(double year) {
        double cycleProgress = ((year - START_YEAR) % ECM_CYCLE_YEARS) / ECM_CYCLE_YEARS;
        if (cycleProgress < 0) cycleProgress += 1.0;
        int elementIndex = (int)Math.Floor(cycleProgress * 5.0);
        if (elementIndex < 0) elementIndex = 0;
        if (elementIndex >= ELEMENTS.Length) elementIndex = ELEMENTS.Length - 1;
        return ELEMENTS[elementIndex];
    }

    private static double SigmoidProb(double val, double threshold) {
        return 1.0 / (1.0 + Math.Exp(-0.25 * (val - threshold)));
    }

    private static RandomEvent GetRandomEventFromLibrary(object library, string key = null) {
        // 对应 TS: getRandomEvent(library, key?)
        if (library is Dictionary<string, List<RandomEvent>> dict) {
            List<RandomEvent> events;
            if (key != null && dict.TryGetValue(key, out events) && events.Count > 0) {
                return events[UnityEngine.Random.Range(0, events.Count)];
            }

            // key 未找到或为空时，这里 TS 里其实不会走到
            return new RandomEvent { title = "波动", desc = "..." };
        }
        else if (library is List<RandomEvent> list) {
            if (list.Count == 0) return new RandomEvent { title = "波动", desc = "..." };
            return list[UnityEngine.Random.Range(0, list.Count)];
        }
        else {
            return new RandomEvent { title = "波动", desc = "..." };
        }
    }

    private static GameDate GetGameDate(double year) {
        int y = (int)Math.Floor(year);
        int mIndex = (int)Math.Floor((year % 1.0) * 12.0);
        string[] months = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC" };
        if (mIndex < 0) mIndex = 0;
        if (mIndex > 11) mIndex = 11;
        return new GameDate { year = y, month = months[mIndex], monthIndex = mIndex };
    }

    private static bool IsInBounds(float x, float y) {
        return x >= 5f && x <= 95f && y >= 5f && y <= 95f;
    }

    private static LocationDef CloneLocation(LocationDef src) {
        return new LocationDef {
            id = src.id,
            x = src.x,
            y = src.y,
            color = src.color,
            label = src.label,
            elementType = src.elementType,
            isDynamic = src.isDynamic,
            ownerId = src.ownerId,
            sceneName = src.sceneName,
            dna = src.dna == null
                ? null
                : new GameDNA {
                    prefix = src.dna.prefix,
                    suffix = src.dna.suffix,
                    genre = src.dna.genre,
                    keywords = src.dna.keywords.ToList()
                },
            isHybrid = src.isHybrid,
            createdAt = src.createdAt,
            pitch = src.pitch,
            synthesisSourceId = src.synthesisSourceId,
            synthesisProgress = src.synthesisProgress
        };
    }

    /// <summary>
    /// Archimedean Spiral Placement（与 TS findSpiralPlacement 控制流一致）
    /// </summary>
    private static bool FindSpiralPlacement(LocationDef anchor, List<LocationDef> existingStructures, out float outX,
        out float outY) {
        const float MIN_DIST_SQ = 36f;
        float angle = 0f;
        float radius = 8f;
        const float maxRadius = 35f;
        const float angleIncrement = 0.5f;
        const float radiusIncrement = 0.2f;
        int attempts = 0;
        const int MAX_TOTAL_ATTEMPTS = 500;

        while (radius < maxRadius && attempts < MAX_TOTAL_ATTEMPTS) {
            float x = anchor.x + Mathf.Cos(angle) * radius;
            float y = anchor.y + Mathf.Sin(angle) * radius;

            if (IsInBounds(x, y)) {
                bool collision = false;
                foreach (var s in existingStructures) {
                    float dx = s.x - x;
                    float dy = s.y - y;
                    if (dx * dx + dy * dy < MIN_DIST_SQ) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    outX = x;
                    outY = y;
                    return true;
                }
            }

            angle += angleIncrement;
            radius += radiusIncrement * (1f / (1f + radius * 0.1f));
            attempts++;
        }

        outX = 0f;
        outY = 0f;
        return false;
    }

    /// <summary>
    /// DNA 合成（对应 synthesizeHybridScene）
    /// </summary>
    private static LocationDef SynthesizeHybridScene(LocationDef source, LocationDef target) {
        if (source.dna == null || target.dna == null) return null;

        ElementConfig sourceEl = ELEMENT_MAP[source.elementType];
        ElementConfig targetEl = ELEMENT_MAP[target.elementType];

        string relationship = "SAME";
        string finalElementType = target.elementType;

        if (sourceEl.next == targetEl.key) {
            relationship = "GENERATE";
            finalElementType = targetEl.key;
        }
        else if (sourceEl.counter == targetEl.key) {
            relationship = "OVERCOME";
            finalElementType = sourceEl.key;
        }
        else if (sourceEl.key == targetEl.key) {
            relationship = "SAME";
        }
        else {
            return null;
        }

        string newName = $"{target.dna.prefix} {source.dna.suffix}";

        var newDna = new GameDNA {
            prefix = target.dna.prefix,
            suffix = source.dna.suffix,
            genre = $"{target.dna.genre}-{source.dna.genre}",
            keywords = new List<string> {
                target.dna.keywords.Count > 0 ? target.dna.keywords[0] : "Unknown",
                source.dna.keywords.Count > 0 ? source.dna.keywords[0] : "Unknown"
            }
        };

        List<string> templates;
        if (relationship == "GENERATE") templates = LORE_LIBRARY.HYBRID_TEMPLATES.GENERATE;
        else if (relationship == "OVERCOME") templates = LORE_LIBRARY.HYBRID_TEMPLATES.OVERCOME;
        else if (relationship == "SAME") templates = LORE_LIBRARY.HYBRID_TEMPLATES.SAME;
        else templates = LORE_LIBRARY.HYBRID_TEMPLATES.DEFAULT;

        string template = templates[UnityEngine.Random.Range(0, templates.Count)];
        string pitch = template
            .Replace("{S_KEY}", source.dna.keywords.Count > 0 ? source.dna.keywords[0] : "Unknown")
            .Replace("{T_KEY}", target.dna.keywords.Count > 0 ? target.dna.keywords[0] : "Unknown")
            .Replace("{S_PREFIX}", source.dna.prefix ?? "")
            .Replace("{T_PREFIX}", target.dna.prefix ?? "")
            .Replace("{S_SUFFIX}", source.dna.suffix ?? "")
            .Replace("{T_SUFFIX}", target.dna.suffix ?? "")
            .Replace("{GENRE}", newDna.genre ?? "");

        var hybrid = new LocationDef {
            id = $"hybrid-{Guid.NewGuid().ToString("N")}",
            x = target.x,
            y = target.y,
            color = ELEMENT_MAP[finalElementType].color,
            label = newName,
            elementType = finalElementType,
            isDynamic = true,
            isHybrid = true,
            dna = newDna,
            sceneName = newName,
            ownerId = source.ownerId,
            createdAt = Time.timeSinceLevelLoadAsDouble,
            pitch = pitch
        };

        return hybrid;
    }

    /// <summary>
    /// Agent 初始化（严格对应 createAgents）
    /// </summary>
    private List<Agent> CreateAgents() {
        var result = new List<Agent>();

        for (int i = 0; i < LEGENDS.Count; i++) {
            var legend = LEGENDS[i];
            var typeDef = ELEMENTS.FirstOrDefault(e => e.key == legend.type);
            if (typeDef == null) throw new Exception($"Invalid type {legend.type}");
            var loc = INITIAL_LOCATIONS.FirstOrDefault(l => l.id == typeDef.location);
            if (loc == null) throw new Exception($"Invalid location {typeDef.location}");

            float randX = Mathf.Clamp(
                loc.x + (UnityEngine.Random.value - 0.5f) * 15f,
                5f, 95f
            );
            float randY = Mathf.Clamp(
                loc.y + (UnityEngine.Random.value - 0.5f) * 15f,
                5f, 95f
            );

            var agent = new Agent {
                id = i,
                name = legend.name,
                type = legend.type,
                role = typeDef.role,
                baseQuote = legend.quote,
                x = randX,
                y = randY,
                targetX = loc.x,
                targetY = loc.y,
                wealth = 100.0,
                energy = 100.0,
                status = "working",
                thought = legend.quote,
                moodTimer = 0,
                waitTimer = UnityEngine.Random.Range(0, 20),
                loiterTimer = 0,
                color = typeDef.color,
                isMoving = false,
                inspirations = new List<string>(),
                project = $"Project: {legend.name.Split(' ')[0]} AI",
                archetypeKey = string.IsNullOrEmpty(legend.archetypeKey) ? "MANAGER" : legend.archetypeKey
            };

            result.Add(agent);
        }

        return result;
    }

    #endregion

    #region ==== Tick 主循环（严格对应 processTick） ====

    private void ProcessTick() {
        // ---- 年份 & 状态快照 ----
        var currentVals = new Dictionary<string, double>(elementValues);
        double prevYear = year;
        double increment = 1.0 / TICKS_PER_YEAR;
        double currentYear = Math.Round(prevYear + increment, 4);

        double globalConfidence = GetGlobalConfidence(currentYear);
        double dynamicGravity = 50.0 + globalConfidence * 25.0;
        ElementDef heavenElement = GetHeavenElement(currentYear);

        // ---- 地点黄金恢复逻辑（与 TS 一致）----
        var nextLocStates = new List<LocationState>();

        foreach (var locState in locationStates) {
            var locDef = structures.FirstOrDefault(l => l.id == locState.id);
            if (locDef == null) {
                nextLocStates.Add(new LocationState {
                    id = locState.id,
                    gold = locState.gold,
                    maxGold = locState.maxGold
                });
                continue;
            }

            double income = 0.5;
            var heavenConf = ELEMENT_MAP[heavenElement.key];

            if (heavenConf.next == locDef.elementType) income += 2.0;
            else if (heavenElement.key == locDef.elementType) income += 3.0;
            else if (heavenConf.counter == locDef.elementType) income -= 0.2;

            double newGold = Math.Min(locState.maxGold, Math.Max(0.0, locState.gold + income));

            nextLocStates.Add(new LocationState {
                id = locState.id,
                gold = newGold,
                maxGold = locState.maxGold
            });
        }

        // 随机清空 crash 标记
        if (UnityEngine.Random.value < 0.1f) {
            currentCrashElement = null;
        }
        
        var newLogs = new List<LogEntry>();
        bool eventTriggered = false;
        string currentEventTitle = "";

        // ---- 历史事件 ----
        var historicalEvent = HISTORICAL_EVENTS
            .FirstOrDefault(e => e.year > prevYear && e.year <= currentYear + 0.001);

        if (historicalEvent != null) {
            bool isCrash = historicalEvent.type == "CRASH";
            if (isCrash) currentCrashElement = historicalEvent.target;
            currentEventTitle = historicalEvent.title;

            newLogs.Insert(0, new LogEntry {
                id = $"hist-{currentYear}",
                year = historicalEvent.year,
                type = isCrash ? "HISTORY_BAD" : "HISTORY_GOOD",
                msg = $"{historicalEvent.title}: {historicalEvent.desc}",
                source = historicalEvent.source,
                target = historicalEvent.target
            });

            if (isCrash) {
                var keys = currentVals.Keys.ToList();
                foreach (var k in keys) {
                    currentVals
                        [k] *= 0.7;
                }

                currentVals[historicalEvent.target] = 10.0;
            }
            else if (historicalEvent.type == "GENERATE") {
                currentVals[historicalEvent.source] -= 15.0;
                currentVals[historicalEvent.target] =
                    Math.Min(100.0, currentVals[historicalEvent.target] + 40.0);
            }
            else {
                currentVals[historicalEvent.target] *= 0.5;
            }

            eventTriggered = true;
        }

        // ---- 随机元素事件（GENERATE/OVERCOME）----
        if (!eventTriggered) {
            // TS: const shuffledKeys = Object.keys(ELEMENT_MAP).sort(() => Math.random() - 0.5);
            // 这里用随机排序达到同样效果
            var shuffledKeys = ELEMENT_MAP.Keys
                .OrderBy(_ => UnityEngine.Random.value)
                .ToList();

            foreach (var key in shuffledKeys) {
                if (eventTriggered) break;

                var elConfig = ELEMENT_MAP[key];
                double val = currentVals[key];

                double localPiFactor = GetElementPiFactor(elConfig.phaseIndex, currentYear);
                bool isHeavenFavored = heavenElement.key == key;
                bool isHeavenCountered = heavenElement.counter == key;

                double gravityPull = (dynamicGravity - val) * BASE_RECOVERY_SPEED;
                if (isHeavenFavored) gravityPull += 0.5;
                if (isHeavenCountered) gravityPull -= 0.5;

                val += gravityPull;
                val += localPiFactor * 2.0;

                double volatility = globalConfidence < -0.3 ? 5.0 : 2.0;
                val += (UnityEngine.Random.value - 0.5) * volatility;

                val = Math.Max(0.0, Math.Min(100.0, val));
                currentVals[key] = val;

                string sourceKey = ELEMENTS.FirstOrDefault(e => e.counter == key)?.key;
                if (!string.IsNullOrEmpty(sourceKey)) {
                    double sourceVal = currentVals[sourceKey];
                    double crashThreshold = dynamicGravity < 40.0 ? 70.0 : 90.0;
                    if (val > crashThreshold && sourceVal < 45.0) {
                        var evt = GetRandomEventFromLibrary(RANDOM_EVENTS.OVERCOME, sourceKey);
                        currentEventTitle = evt.title;

                        newLogs.Insert(0, new LogEntry {
                            id = $"{currentYear}-ov-{key}",
                            year = currentYear,
                            type = "OVERCOME",
                            msg = $"{evt.title}: {evt.desc}",
                            source = sourceKey,
                            target = key
                        });

                        currentVals[key] *= 0.6;
                        currentVals[sourceKey] += 10.0;
                        currentCrashElement = key;
                        eventTriggered = true;
                        break;
                    }
                }

                double growthThreshold = 80.0 - (globalConfidence * 20.0);
                if (val > growthThreshold && UnityEngine.Random.value < SigmoidProb(val, growthThreshold)) {
                    string nextKey = elConfig.next;
                    var evt = GetRandomEventFromLibrary(RANDOM_EVENTS.GENERATE, key);
                    currentEventTitle = evt.title;

                    newLogs.Insert(0, new LogEntry {
                        id = $"{currentYear}-gen-{key}",
                        year = currentYear,
                        type = "GENERATE",
                        msg = $"{evt.title}: {evt.desc}",
                        source = key,
                        target = nextKey
                    });

                    currentVals[key] -= 25.0;
                    currentVals[nextKey] = Math.Min(100.0, currentVals[nextKey] + 35.0);
                    eventTriggered = true;
                }
            }
        }

        // ---- BEAR 事件 ----
        if (!eventTriggered && globalConfidence < -0.6 && UnityEngine.Random.value < 0.1f) {
            var evt = GetRandomEventFromLibrary(RANDOM_EVENTS.BEAR);
            currentEventTitle = evt.title;

            newLogs.Insert(0, new LogEntry {
                id = $"{currentYear}-bear",
                year = currentYear,
                type = "OVERCOME",
                msg = $"{evt.title}: {evt.desc}",
                source = "EARTH",
                target = "EARTH"
            });

            var keys = currentVals.Keys.ToList();
            foreach (var k in keys) {
                currentVals[k] -= 2.0;
            }

            if (UnityEngine.Random.value < 0.5f) {
                currentCrashElement = "EARTH";
            }

            eventTriggered = true;
        }

        if (!string.IsNullOrEmpty(currentEventTitle)) {
            lastEventTitle = currentEventTitle;
        }

        // ---- Agent + Structure 更新，与 TS setAgents(prevAgents => { ... }) 等价 ----
        // 1) 构建空间网格
        var spatialGrid = new Dictionary<string, List<Agent>>();
        foreach (var a in agents) {
            string gridKey = $"{Mathf.FloorToInt(a.x / 20f)},{Mathf.FloorToInt(a.y / 20f)}";
            if (!spatialGrid.TryGetValue(gridKey, out var list)) {
                list = new List<Agent>();
                spatialGrid[gridKey] = list;
            }

            list.Add(a);
        }

        var newStructures = structures.Select(CloneLocation).ToList();
        bool structUpdates = false;

        // ---- 2) 结构合成（synthesisProgress）----
        var structuresToRemove = new HashSet<string>();
        var structuresToAdd = new List<LocationDef>();

        for (int i = 0; i < newStructures.Count; i++) {
            var s = newStructures[i];
            if (!string.IsNullOrEmpty(s.synthesisSourceId) && s.synthesisProgress.HasValue) {
                structUpdates = true;
                float newProgress = s.synthesisProgress.Value + 2f;

                if (newProgress >= 100f) {
                    var sourceStruct = newStructures.FirstOrDefault(ss => ss.id == s.synthesisSourceId);
                    if (sourceStruct != null) {
                        var hybrid = SynthesizeHybridScene(sourceStruct, s);
                        if (hybrid != null) {
                            var sourceEl = ELEMENT_MAP[sourceStruct.elementType];
                            var targetEl = ELEMENT_MAP[s.elementType];
                            bool isGenerating = sourceEl.next == targetEl.key;

                            string logTemplate = LORE_LIBRARY.EVENT_LOGS.MERGE[
                                UnityEngine.Random.Range(0, LORE_LIBRARY.EVENT_LOGS.MERGE.Count)
                            ];
                            newLogs.Insert(0, new LogEntry {
                                id = $"merge-{Guid.NewGuid():N}",
                                year = year,
                                type = "HISTORY_GOOD",
                                msg =
                                    $"{logTemplate} [{hybrid.label}]: A {hybrid.dna?.genre} featuring {string.Join(" & ", hybrid.dna?.keywords ?? new List<string>())}!",
                                source = sourceStruct.elementType,
                                target = s.elementType
                            });

                            if (isGenerating) {
                                // 保留原 target，额外添加 hybrid
                                s.synthesisSourceId = null;
                                s.synthesisProgress = null;
                                newStructures[i] = s;
                                structuresToAdd.Add(hybrid);
                            }
                            else {
                                // 删除 source & target，用 hybrid 替代
                                structuresToRemove.Add(s.id);
                                structuresToRemove.Add(sourceStruct.id);
                                structuresToAdd.Add(hybrid);
                            }
                        }
                    }
                    else {
                        s.synthesisSourceId = null;
                        s.synthesisProgress = null;
                        newStructures[i] = s;
                    }
                }
                else {
                    s.synthesisProgress = newProgress;
                    newStructures[i] = s;
                }
            }
        }

        if (structuresToRemove.Count > 0 || structuresToAdd.Count > 0) {
            newStructures = newStructures
                .Where(s => !structuresToRemove.Contains(s.id))
                .ToList();
            newStructures.AddRange(structuresToAdd);
            structUpdates = true;
        }

        // ---- 3) Agent 更新（与 TS 中 map(agent => { ... }) 完整对应）----
        var nextAgents = new List<Agent>();

        foreach (var agent in agents) {
            double agentVal = currentVals[agent.type];
            var myDef = ELEMENT_MAP[agent.type];
            if (!BAZI_ARCHETYPES.TryGetValue(agent.archetypeKey, out var archetype)) {
                archetype = BAZI_ARCHETYPES["MANAGER"];
            }

            double wealth = agent.wealth;
            double energy = agent.energy;
            string status = agent.status;
            string thought = agent.thought;
            int moodTimer = agent.moodTimer;
            int waitTimer = agent.waitTimer;
            int loiterTimer = agent.loiterTimer;
            bool isMoving = false;
            var inspirations = new List<string>(agent.inspirations);
            string project = agent.project;
            float x = agent.x;
            float y = agent.y;
            float targetX = agent.targetX;
            float targetY = agent.targetY;

            // 1. UBI
            wealth += 0.5;

            // 2. Passive income
            if (status == "working") {
                wealth += (agentVal / 1.5);
            }

            if (moodTimer > 0) moodTimer--;
            if (energy > 0) energy -= 0.2;
            if (status == "resting") energy += 1.5;

            if (wealth > 200 && status == "rich" && moodTimer == 0 && UnityEngine.Random.value < 0.1f) {
                status = "working";
                var elLabel = ELEMENTS.First(e => e.key == agent.type).label.Split(' ')[0];
                project = $"R&D: Next-Gen {elLabel}";
            }

            // --- Construction（阈值和数值完全照 TS）---
            if (wealth > 60.0) {
                var elementAnchor = INITIAL_LOCATIONS.FirstOrDefault(l => l.elementType == agent.type);
                if (elementAnchor != null) {
                    if (!LEGENDARY_SCENES.TryGetValue(agent.type, out var myScenes)) {
                        myScenes = null;
                    }

                    if (myScenes != null && myScenes.Count > 0) {
                        var scene = myScenes[UnityEngine.Random.Range(0, myScenes.Count)];

                        if (UnityEngine.Random.value < 0.5f) {
                            if (FindSpiralPlacement(elementAnchor, newStructures, out float px, out float py)) {
                                wealth -= 30.0;
                                thought = $"BUILDING: {scene.name.ToUpper()}";
                                status = "working";
                                moodTimer = 30;

                                string logTemplate = LORE_LIBRARY.EVENT_LOGS.CONSTRUCT[
                                    UnityEngine.Random.Range(0, LORE_LIBRARY.EVENT_LOGS.CONSTRUCT.Count)
                                ];

                                var newStruct = new LocationDef {
                                    id = $"build-{Guid.NewGuid():N}-{agent.id}",
                                    x = px,
                                    y = py,
                                    color = elementAnchor.color,
                                    label = scene.name,
                                    elementType = agent.type,
                                    isDynamic = true,
                                    ownerId = agent.id,
                                    sceneName = scene.name,
                                    dna = scene.dna,
                                    createdAt = Time.timeSinceLevelLoadAsDouble
                                };

                                newStructures.Add(newStruct);

                                newLogs.Insert(0, new LogEntry {
                                    id = $"build-{Guid.NewGuid():N}",
                                    year = currentYear,
                                    type = "HISTORY_GOOD",
                                    msg = $"{agent.name} {logTemplate}",
                                    source = agent.type,
                                    target = "EARTH"
                                });

                                structUpdates = true;
                            }
                        }
                    }
                }
            }

            // 找最近的 Structure
            float nearestLocDistSq = float.MaxValue;
            LocationDef nearestLocDef = newStructures[0];

            foreach (var loc in newStructures) {
                float dx = loc.x - x;
                float dy = loc.y - y;
                float dSq = dx * dx + dy * dy;
                if (dSq < nearestLocDistSq) {
                    nearestLocDistSq = dSq;
                    nearestLocDef = loc;
                }
            }

            // ---- Anti-loitering + Productivity ----
            if (nearestLocDistSq < 100f) {
                string locEl = nearestLocDef.elementType;
                int locStateIndex = nextLocStates.FindIndex(ls => ls.id == nearestLocDef.id);
                double currentGoldAtLoc = locStateIndex >= 0 ? nextLocStates[locStateIndex].gold : 50.0;

                var locElDef = ELEMENT_MAP[locEl];

                // 1. Productivity
                if (locElDef.next == agent.type) {
                    if (currentGoldAtLoc > 5.0) {
                        double harvest = 80.0;
                        if (locStateIndex >= 0)
                            nextLocStates[locStateIndex].gold -= harvest;

                        wealth += harvest;
                        if (moodTimer == 0) thought = "YANG: FUNDING SECURED";
                    }

                    if (UnityEngine.Random.value < 0.05f) {
                        if (GAME_CONCEPTS.TryGetValue(locEl, out var conceptList) && conceptList.Count > 0) {
                            var newInspo = conceptList[UnityEngine.Random.Range(0, conceptList.Count)];
                            if (!inspirations.Contains(newInspo)) {
                                inspirations.Add(newInspo);
                                thought = $"YIN: IDEA [{newInspo}]";
                                status = "inspired";

                                string prefix = PROJECT_PREFIXES[UnityEngine.Random.Range(0, PROJECT_PREFIXES.Length)];
                                project = $"{prefix}: {newInspo}";
                                moodTimer = 10;
                            }
                        }
                    }

                    energy = Math.Min(100.0, energy + 2.0);
                }
                else if (locElDef.counter == agent.type) {
                    if (archetype.key == "STRATEGIST") {
                        energy += 1.0;
                        if (UnityEngine.Random.value < 0.05f)
                            thought = "STRATEGY: CRISIS MGMT";
                    }
                    else {
                        wealth -= 2.0;
                        if (UnityEngine.Random.value < 0.05f && moodTimer == 0) {
                            thought = "EARTH: RESTRICTED";
                            status = "stressed";
                            moodTimer = 5;
                        }
                    }
                }

                // 2. Loiter check
                if (waitTimer > 0 && !isMoving) {
                    loiterTimer = loiterTimer + 1;
                    int ttl = 12 + UnityEngine.Random.Range(0, 4);
                    if (loiterTimer > ttl) {
                        loiterTimer = 0;
                        waitTimer = 0;
                        thought = "TTL EXPIRED: MOVING...";
                        targetX = x + (UnityEngine.Random.value - 0.5f) * 60f;
                        targetY = y + (UnityEngine.Random.value - 0.5f) * 60f;
                        status = "working";
                    }
                }
                else {
                    loiterTimer = 0;
                }
            }
            else {
                loiterTimer = 0;
            }

            // ---- 邻居交互（TEN GODS）----
            if (moodTimer == 0 && UnityEngine.Random.value < 0.3f) {
                string gridKey = $"{Mathf.FloorToInt(x / 20f)},{Mathf.FloorToInt(y / 20f)}";
                spatialGrid.TryGetValue(gridKey, out var potentialNeighbors);
                Agent neighbor = null;

                if (potentialNeighbors != null) {
                    foreach (var n in potentialNeighbors) {
                        if (n.id == agent.id) continue;
                        float dx = n.x - x;
                        float dy = n.y - y;
                        if (dx * dx + dy * dy < 64f) {
                            neighbor = n;
                            break;
                        }
                    }
                }

                if (neighbor != null) {
                    string neighborEl = neighbor.type;

                    if (myDef.next == neighborEl) {
                        string shortName = neighbor.name.Split(' ').Last();
                        string evtText = TEN_GODS_EVENTS.OUTPUT[
                            UnityEngine.Random.Range(0, Math.Min(3, TEN_GODS_EVENTS.OUTPUT.Length))
                        ];
                        thought = $"{evtText} w/ {shortName}";
                        wealth -= 5.0;
                        energy -= 2.0;
                    }
                    else if (myDef.prev == neighborEl) {
                        energy = Math.Min(100.0, energy + 5.0);
                        if (UnityEngine.Random.value < 0.1f) {
                            if (GAME_CONCEPTS.TryGetValue(neighborEl, out var mentorList) && mentorList.Count > 0) {
                                string learned = mentorList[UnityEngine.Random.Range(0, mentorList.Count)];
                                if (!inspirations.Contains(learned)) {
                                    inspirations.Add(learned);
                                    thought = $"LEARNED: {learned}";
                                    status = "inspired";
                                    project = $"Collab: {learned}";
                                }
                            }
                        }
                    }
                    else if (myDef.counter == neighborEl) {
                        string shortName = neighbor.name.Split(' ').Last();
                        thought = $"Dominating {shortName}";
                        wealth += 3.0;
                        if (archetype.key == "WOLF") wealth += 2.0;
                    }
                    else if (neighborEl == myDef.counter) {
                        string shortName = neighbor.name.Split(' ').Last();
                        thought = $"Avoid {shortName}";
                        status = "panic";
                        energy -= 5.0;
                    }
                    else {
                        thought = "Brainstorming...";
                        energy += 1.0;
                    }

                    moodTimer = 10;
                }
            }

            // ---- EPIPHANY: GOTY ----
            if (inspirations.Count >= 3 && wealth > 120.0 && UnityEngine.Random.value < 0.01f) {
                status = "rich";
                wealth += 50.0;
                thought = "EPIPHANY: GAME OF THE YEAR!";
                string title = $"GOTY: {inspirations[0]}";

                if (lastEventTitle != title) {
                    string logTemplate = LORE_LIBRARY.EVENT_LOGS.EPIPHANY[
                        UnityEngine.Random.Range(0, LORE_LIBRARY.EVENT_LOGS.EPIPHANY.Count)
                    ];
                    newLogs.Insert(0, new LogEntry {
                        id = $"epiphany-{currentYear}-{agent.id}",
                        year = currentYear,
                        type = "HISTORY_GOOD",
                        msg = $"{agent.name} {logTemplate}",
                        source = agent.type,
                        target = agent.type
                    });
                    lastEventTitle = title;
                }

                project = $"Released: {inspirations[0]}";
                inspirations.Clear();
                moodTimer = 20;
            }

            // ---- 移动逻辑 ----
            double speed =
                (globalConfidence > 0.5 ? 4.0 :
                    globalConfidence < -0.5 ? 1.0 : 2.0) * speedMultiplier;

            float dxMove = targetX - x;
            float dyMove = targetY - y;
            float distSq = dxMove * dxMove + dyMove * dyMove;

            if (distSq > 4f) {
                float dist = Mathf.Sqrt(distSq);
                if (energy > 10.0) {
                    x += (dxMove / dist) * (float)speed;
                    y += (dyMove / dist) * (float)speed;
                    isMoving = true;
                }
                else {
                    x += (dxMove / dist) * (float)(speed * 0.5);
                    y += (dyMove / dist) * (float)(speed * 0.5);
                    status = "resting";
                    thought = "LOW ENERGY...";
                }
            }
            else {
                isMoving = false;
                waitTimer--;

                if (waitTimer <= 0) {
                    if (status == "panic") {
                        targetX = UnityEngine.Random.value < 0.5f ? 10f : 90f;
                        targetY = UnityEngine.Random.value < 0.5f ? 10f : 90f;
                    }
                    else {
                        LocationDef bestLoc = newStructures[0];
                        double bestScore = double.NegativeInfinity;
                        var bias = archetype.bias;
                        double rationality = 1.0 - bias.irrationality;

                        foreach (var loc in newStructures) {
                            string locEl = loc.elementType;
                            var locDef2 = ELEMENT_MAP[locEl];
                            double score = 0.0;

                            if (wealth < 40.0) {
                                if (locDef2.next == agent.type) score += 50.0;
                                if (locEl == agent.type) score += 30.0;
                                if (myDef.counter == locEl) score += 40.0;
                            }
                            else if (energy < 30.0) {
                                if (locDef2.next == agent.type) score += 100.0;
                            }
                            else {
                                if (locDef2.next == agent.type) score += 20.0;
                            }

                            if (bias.obsessions.Contains(locEl))
                                score += 100.0 * bias.irrationality;

                            if (bias.phobias.Contains(locEl))
                                score -= 100.0 * bias.irrationality;

                            if (locDef2.counter == agent.type) {
                                score -= 50.0 * rationality * (1.0 - bias.riskAppetite);
                            }

                            score += UnityEngine.Random.value * 20.0;

                            if (score > bestScore) {
                                bestScore = score;
                                bestLoc = loc;
                            }
                        }

                        targetX = bestLoc.x + (UnityEngine.Random.value - 0.5f) * 20f;
                        targetY = bestLoc.y + (UnityEngine.Random.value - 0.5f) * 20f;
                    }

                    targetX = Mathf.Clamp(targetX, 5f, 95f);
                    targetY = Mathf.Clamp(targetY, 5f, 95f);
                    waitTimer = 20 + UnityEngine.Random.Range(0, 40);
                }
            }

            // ---- Crash / status 终态 ----
            string activeCrash = currentCrashElement;

            if ((activeCrash == agent.type) || agentVal < 20.0 || wealth <= 0.0) {
                status = "bankrupt";
                thought = "ERR: 402 PAYMENT";
                wealth = Math.Max(0.0, wealth);
            }
            else if (!string.IsNullOrEmpty(activeCrash) && activeCrash != agent.type) {
                status = "panic";
                thought = "WARN: CRASH DETECTED";
            }
            else if (agentVal > 80.0 && wealth > 150.0) {
                status = "rich";
                if (moodTimer == 0) thought = "SYS: OPTIMIZED";
            }
            else if (status != "inspired" && status != "stressed" && status != "resting") {
                if (globalConfidence < -0.5) {
                    status = "panic";
                    if (moodTimer == 0) thought = "MODE: HIBERNATE";
                }
                else {
                    status = "working";
                }
            }

            nextAgents.Add(new Agent {
                id = agent.id,
                name = agent.name,
                type = agent.type,
                role = agent.role,
                baseQuote = agent.baseQuote,
                x = x,
                y = y,
                targetX = targetX,
                targetY = targetY,
                wealth = wealth,
                energy = energy,
                status = status,
                thought = thought,
                moodTimer = moodTimer,
                waitTimer = waitTimer,
                loiterTimer = loiterTimer,
                color = agent.color,
                isMoving = isMoving,
                inspirations = inspirations,
                project = project,
                archetypeKey = agent.archetypeKey
            });
        }

        // 如果结构发生变化，应用回主状态
        if (structUpdates) {
            structures = newStructures;
        }

        // ---- 最终写回全局状态 ----
        if (eventTriggered) {
            lastLogYear = currentYear;
        }

        year = currentYear;
        elementValues = currentVals;
        locationStates = nextLocStates;
        if (newLogs.Count > 0) {
            // newLogs + 旧日志，最多保留 50 条
            newLogs.AddRange(logs);
            logs = newLogs.Take(50).ToList();
        }

        agents = nextAgents;

        // 同步为新结构自动创建 LocationState（与 useEffect([structures]) 对应）
        SyncLocationStatesWithStructures();

        if (currentYear >= 2030.0) {
            isRunning = false;
        }
    }

    private void SyncLocationStatesWithStructures() {
        var existingIds = new HashSet<string>(locationStates.Select(p => p.id));
        var newStates = new List<LocationState>();

        foreach (var s in structures) {
            if (!existingIds.Contains(s.id)) {
                newStates.Add(new LocationState {
                    id = s.id,
                    gold = 50.0,
                    maxGold = s.isHybrid ? 300.0 : 150.0
                });
            }
        }

        if (newStates.Count > 0) {
            locationStates.AddRange(newStates);
        }
    }

    #endregion

    #region ==== 只读访问接口，方便你在 Unity UI 中展示 ====

    public IReadOnlyDictionary<string, double> ElementValues => elementValues;
    public IReadOnlyList<Agent> Agents => agents;
    public IReadOnlyList<LocationDef> Structures => structures;
    public IReadOnlyList<LocationState> LocationStates => locationStates;
    public IReadOnlyList<LogEntry> Logs => logs;

    public GameDate CurrentGameDate => GetGameDate(year);
    public ElementDef CurrentHeavenElement => GetHeavenElement(year);

    #endregion
}